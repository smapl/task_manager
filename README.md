# task_manager
Персонализированный сервис task manager, позволяющий пользователю ставить себе задачи, отражать в системе изменение их статуса и просматривать историю задач.

### Рекаомендации к использованию 

Для корректной работы с данным проектом рекомендуится ОС `Linux`, а также связка `poetry` + `pyenv`.  
База данных, используемая в этом проекте, это postgresql, поэтому она также должна быть настроена. 

##### Структура бд
```
| (database)
task_manager
    |
    | (table)
    --- users_data
        |
        | (column names)
        --- id SERIAL
        --- login (VARCHAR(30))
        --- pawwsord (VARCHAR(30))
        --- authtoken (VARCHAR(100))
    |
    | (table)
    ---tasks
        |
        | (column names)
        --- id SERIAL
        --- name (VARCHAR(100))
        --- description (VARCHAR(300))
        --- create_datetime (TIMESTAMP)
        --- status (VARCHAR(100))
        --- planned_completed (TIMESTAMP)
        --- user_id (VARCHAR(100))
        --- finish_datetime (TIMESTAMP)
    |
    | (table)
    ---old_version
        |
        | (column names)
        --- id SERIAL
        --- name (VARCHAR(100))
        --- description (VARCHAR(300))
        --- status (VARCHAR(100))
        --- planned_completed (TIMESTAMP)
        --- finish_datetime (TIMESTAMP)
```

##### Настройка рабочей среды

После клонирования проекта перейдите в корневую директорию и пропишите следующие команды:  
```
pyenv local 3.8.5
poetry install
poetry run python src/__main__.py --login login --password password --host localhost --db_name task_manager
```
Последняя строка запускате сервис, при запуске сервиса в аргументах командной строки передаются: логин пользователя postgresqlб пароль пользователя, хост на котором работает бд и название бд; соответсвенно .  
Запустить проекта можно также прописав в консоль из корневой папки проекта следующее:  
```
bash entrypoint.sh
```

### Документация к файлам проекта 


1.    `src/` :  
        `__main__.py` - файл, который запуск сам сервис ;  

2.    `src/task_manager` :  
        `__init__.py` - означает что папка является модулем ;  
        `create_app.py` - создает само приложение и там прописываются необходимые конфигурации ;  
        `handler.py` - основаная бизнес логика сервис ;  
        `views.py` - прописываются все эндпоинты сервисы, каждый эндпоинт принимает параметры запроса и передает их в `handler.py`, для дальнейшей обработки ;  
        `utils.py` - функции, напрямую не относящиеся к бизнес логики сервиса .  

В директории `test` находятся `.json` файлы описывающие параметры запроса к каждому эндпоинта, а в файле `test_query.py`, реализованы функции, показывающие работу каждого эндпоинта данного сервиса .  

### Документация к проекту

#### Модули
в данном проекте использовались следующие зависимости:
1. `Flask` - фрэйиворк для создания самого сервиса ;  
2. `psycopg2-binary` - Для работы с postgresql ;  
3. `loguru` - для журнала логирования (журнал логирования только StramHandler) ;  
4. `requests` - для теста проекта, отправки соответсвующих запросов и проверки их на работоспособность (реализация в папке `test`) ;  
5. `werkzeug` - зависимость к фрэйморву flask, также с помощью его осущестлялось хэширование паролей .  


#### Пояснение реализации проекта
Основная бизнес логика проекта находится в файле `src/task_manager/handler`. В этом модуле написан класс и каждый его метод отвечает за отдельный endpoint сервиса, разберем по порядку каждый метод:  

1. `create_user` - метод, который создает пользователя в данном сервисе.  
В данный метод необходимо передать логин и пароль, который ввел пользователь (приходит `POST` запросом), перед передачей на уровне принятия аргументов в функции `src/task_manager/views.py` пароль шифруется через `werkzeug.security` модуль `generate_password_hash`, далее в postgresql отправляет запрос на проверку существования польщователя с таким никнеймом, если ответ с бд не равен `None` значит пользователь уже существует и в response выходит соответсвующая ошибка, если же такого никнейма не существует, то логин и зашифрованный пароль отправляю в бд и в ответе пользователь получает ключ аутентификации, который генерурется через `sha256` аргументом которого является текущая дата и время точностью до долисекунд преставленная в строковом типе данных. Далее ключ аутентификации иоспользуется в аргументе каждого запроса, подразумевается, что фронт его будет передавать или же сам пользователь.
Пример request Json:
```
{
    "login": "Smapl",
    "Password": "qwerty"
}
```

2. `create_task` - метод создания задачи.
На вход принимает следующие параметры:  
```
name - название задачи (ограничение в 100 символов), является обязательным аргументом ;  
description - описание задачи (ограничение в 300 символов), является обязательным аргументом ;  
status - статус задачи. Может содержать в себя один из следующих вариантов: new, work, planned, completed;  
Идется проверка на корректность введенного статус;  
create_datetime - время создания задачи, проставляется автоматически;  
planned_completed - планируемое время завершения задачи (формат yyyy-mm-dd hh:mm), является необязательным ;  
user_token - токен, который идентифицирует пользователя и присваивает ему задачу .  
```
После принятия параметров, по токену в бд ищется `user_id` и данные заполняются в `postgresql` вместе с `user_id`.  
в ответе будет `success` .  
Пример request Json:
```
{
    "name": "create testing",
    "description": "me need create test for company",
    "status": "New",
    "planned_completed": "2020-10-08 08:30",
    "authtoken": "b95dda629968cf2293642deb70b6e3eb0882f84c090ffce43108aa73efd23264"
}
```

3. `check_task_status` - метод вывода списка задач.  
На вход принимает следующие параметры: 
```
user_token - токен идентификации пользователя ;  
status_filter - фильтрация вывода задач (тип данных json) ;  
```
Пример параметра фильтра:
```
{
"status_filter":{"status":"completed"}
}
```
После принятия аргументов, программа по токену ищет `user_id` так как он связывает пользователя с задачей, чтобы пользователь мог видеть только свои задачи. Далее идет проверка на то передался ли `status_filter` в параметрах, если передался, то запрос в бд делается с учетом фильтраци, если не передался, то соответсвенно без фильтрации. 
Пример request Json:
```
{
    "authtoken": "914fe08d9f8eaadddf5073516ba89976d8023812bc60d474f051f57a8e91eaa3",
    ""status_filter":{"status":"completed"}
}
```

4. `change_task_rows` - метод изменения данных в задаче.  
Данные, которые можно менять - название задачи (name), описание задачи (description), статус задачи (status), планируемая дата завершения задачи (planned_completed) .  
На вход метода поступают следующие параметры: 
```
task_id - id задачи (предполагается что в боевом проекте будет приходить с фронта) ;  
user_token - токен идентификации пользователя ;  
new_values - задачи, которые нужно изменить и на что .
```
пример параметра `new_values`:
```
"new_values": {
        "status": "work",
        "planned_completed": "2020-11-12 16:30",
        "name": "creating task",
        "description": "i can not create this task"
    }
```
В данном методе токен пользователя нужжен для того, чтобы проверить относится ли задача которая пришла из параметров к его списку задач, если не относится, то сервис выдает ошибку.  
Перед обновлением задач скрипт записывает старые данные этой задачи в отдельную переменную (об этом в конце пункта). Далее сервис смотрит какие задачи надо изменить и на что, корректно записывает в переменную для парвильного запроса в бд и отправляет данный запрос.
Старые данные задачи записывались для того, чтобы перенести их в отдельную таблицу `old_version` для дальнейшего просмотра истории задач.  
Если после изменения задачи статус поменялся на `completed`, то в таблице автоматически проставляется время завершения задачи.
Пример request Json:
```
{
    "authtoken": "914fe08d9f8eaadddf5073516ba89976d8023812bc60d474f051f57a8e91eaa3",
    "task_id": "1",
    "new_values": {
        "status": "work",
        "planned_completed": "2020-11-12 16:30",
        "name": "creating task",
        "description": "i can not create this task"
    }
}
```

5. `check_history_change` - История изменения задачи .  
На вход принимает следующие параметры: 
```
user_token - токен идентификации пользователя ;  
task_id - id задачи, чью историю пользователь хочет просмотреть . 
```
Данный метод сначала ищет `user_id` для проверки того, что ему можно смотреть историю данной задачи, если проверка прошла неудачно, то в ответе выходит ошибка.  
Далее сервис ищет в таблице `old_version` все версии по этой задаче засчет `task_id`. В результате поиска получается кортеж со спискаит всех задач, после чего идет преображения каждого списка в словарь где ключ это название стобца (название поля задачи (например description)), а значением его резцльтат, результаты `None` учитываются и не входят в данный словарь.  
На выходе получается список диктов со значениями всех версий задачи.  
Пример request Json:
```
{
    "authtoken": "914fe08d9f8eaadddf5073516ba89976d8023812bc60d474f051f57a8e91eaa3",
    "task_id": "1"
}
```


Также стоит отметить что при каждом обращении к эндпоинту открывается коннект к базе данных и как только эндпоинт выдает результат коннект закрывается. Это сделано для того, чтобы при большом кол-ве пользователей не было открыто много подключений. 
Не совсем коррекное решение .  

#### Пояснения к некоторым реализациям проекта 

1. Функция `avoid_sql_injection` из `src/task_manager/utils.py` - заменяет определенные символы из строковой переменной, дабы избежать SQL инъекций ;  
2. При изменении значений даски, если статус становится `completed`, то в колонку finish_datetime автоматически проставляется время выполнения этого проекта ;  

#### Примечания 
В ветке `dev_swagger` находится свагер данного сервиса .  

#### Полезные ссылки 

1. [poetry](https://github.com/python-poetry/poetry)
2. [pyenv](https://github.com/pyenv/pyenv)